import groovy.json.JsonSlurper

plugins {
    id 'java'
    id 'com.gradleup.shadow' version '9.0.0-beta4'
    id 'org.hidetake.ssh' version '2.11.2'
}

group = project.group
version = project.version
description = project.description

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(project.javaVersion)
    }
}

repositories {
    maven {
        url = uri('https://nexus.ailis.de/content/groups/public/')
    }
    mavenCentral()
}

dependencies {
    implementation 'org.usb4java:usb4java:1.3.0'
//    implementation 'org.openpnp:opencv:4.9.0-0'
}

tasks.assemble.dependsOn(shadowJar)

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.jar {
    manifest {
        attributes(
                'Main-Class': 'RobotControl.DriverServer'
        )
    }
}

def configFile = file('deployment.json')

if (!configFile.exists()) {
    println("Configuration file 'deployment.json' not found. Creating a template...")

    def templateContent = '''{
  "hosts": [
    {
      "name": "exampleHost",
      "hostname": "example.com",
      "username": "user123",
      "password": "superSecurePassword",
      "port": 22,
      "fileTransfer": [
        {
          "directory": "/remote/deploy/dir",
          "files": [
            {
              "directory": "${rootDir}/build",
              "files": [
                "program-${version}.jar"
              ]
            },
            {
              "directory": "${rootDir}/resources"
            },
            {
              "files": "${rootDir}/docs/**/*.html"
            }
          ]
        }
      ],
      "commands": [
        "echo 'Hello from remote server!'"
      ]
    }
  ]
}'''

    configFile.text = templateContent
    throw new GradleException("Template 'deployment.json' has been created. Please fill in the required details, or if no desired remotes, leave the file blank and rerun the build.")
}

def jsonSlurper = new JsonSlurper()
def hostsConfig = jsonSlurper.parse(configFile)

String resolvePlaceholders(String value) {
    return value.replaceAll(/\$\{([^}]+)\}/) { match ->
        def key = match[1]
        def resolved = project.hasProperty(key) ? project.property(key) : null
        if (resolved == null) {
            logger.warn("Warning: No value found for key: ${key}")
            return ""
        }
        return resolved
    }
}

void resolveConfigPlaceholders(Object node) {
    if (node instanceof Map) {
        node.each { key, value ->
            if (value instanceof String) {
                node[key] = resolvePlaceholders(value)
            } else {
                resolveConfigPlaceholders(value)
            }
        }
    } else if (node instanceof List) {
        node.eachWithIndex { value, idx ->
            if (value instanceof String) {
                node[idx] = resolvePlaceholders(value)
            } else {
                resolveConfigPlaceholders(value)
            }
        }
    }
}
resolveConfigPlaceholders(hostsConfig)

ssh.remotes {
    hostsConfig.hosts.each { hostConfig ->
        def remoteName = hostConfig.name
        println("Configuring remote host: $remoteName")

        "$remoteName" {
            host = hostConfig.hostname
            user = hostConfig.username
            port = hostConfig.port ?: 22 // Default to port 22 if not specified
            if (hostConfig.password) {
                password = hostConfig.password
            } else if (hostConfig.keyFile) {
                identity = hostConfig.keyFile
            } else {
                throw new GradleException("No password or keyFile specified for host: $remoteName")
            }
        }
    }
}
ssh.settings {
    knownHosts = project.hasProperty('knownHosts') ? project.knownHosts : allowAnyHosts
}

// register tasks for the deployment.json config
hostsConfig.hosts.each { hostConfig ->
    hostConfig.tasks.each { hostTask, taskConfig ->
        tasks.register("$hostConfig.name-$hostTask") {
            group = 'deployment'
            if(taskConfig.depends) {
                taskConfig.depends.each { task ->
                    if(task instanceof Map) {
                        if(task.gradle && task.gradle instanceof Map) {
                            task.gradle.each { gradleTask ->
                                dependsOn(gradleTask)
                            }
                        }
                    } else if(task instanceof String) {
                        dependsOn("$hostConfig.name-$task")
                    }
                }
            }

            doLast {
                fileTransferBlock(hostConfig, taskConfig)
                remoteCommandsBlock(hostConfig, taskConfig)
                awaitCommandsBlock(hostConfig, taskConfig)
            }
        }
    }
}

void fileTransferBlock(hostConfig, taskConfig) {
    ssh.run {
        session(ssh.remotes[hostConfig.name]) {
            taskConfig.fileTransfer.each { transferConfig ->
                def remoteDir = transferConfig.directory
                if (!remoteDir) {
                    throw new GradleException("Remote directory is not specified for host: ${taskConfig.name}")
                }

                transferConfig.files.each { fileConfig ->
                    if (fileConfig.directory && fileConfig.files) {
                        def localDir = resolvePlaceholders(fileConfig.directory)
                        def localFilePatterns = fileConfig.files.collect { resolvePlaceholders(it) }
                        println("Uploading files from $localDir to $remoteDir with patterns: $localFilePatterns")

                        localFilePatterns.each { pattern ->
                            fileTree(dir: localDir, include: pattern).visit { fileDetails ->
                                if (!fileDetails.directory) {
                                    def relativePath = fileDetails.relativePath.toString()
                                    def remotePath = "$remoteDir/$relativePath"
                                    def remoteParentDir = remotePath.substring(0, remotePath.lastIndexOf('/'))

                                    // Ensure the parent directory exists
                                    execute "mkdir -p $remoteParentDir"

                                    println("Uploading: $fileDetails.file to $remotePath")
                                    put from: fileDetails.file, into: remotePath
                                }
                            }
                        }
                    } else if (fileConfig.directory) {
                        def localDir = resolvePlaceholders(fileConfig.directory)
                        println("Uploading directory: $localDir to $remoteDir")
                        fileTree(localDir).visit { fileDetails ->
                            if (!fileDetails.directory) {
                                def relativePath = fileDetails.relativePath.toString()
                                def remotePath = "$remoteDir/$relativePath"
                                def remoteParentDir = remotePath.substring(0, remotePath.lastIndexOf('/'))

                                // Ensure the parent directory exists
                                execute "mkdir -p $remoteParentDir"

                                println("Uploading: $fileDetails.file to $remotePath")
                                put from: fileDetails.file, into: remotePath
                            }
                        }
                    } else if (fileConfig.files) {
                        def localFiles = resolvePlaceholders(fileConfig.files)

                        // Wildcard file selection
                        if (localFiles.contains("**")) {
                            def baseDir = localFiles.substring(0, localFiles.indexOf("**")).trim()
                            println("Uploading wildcard files from: $baseDir with pattern: $localFiles to $remoteDir")

                            fileTree(dir: baseDir, include: localFiles.substring(baseDir.length())).visit { fileDetails ->
                                if (!fileDetails.directory) {
                                    def relativePath = fileDetails.relativePath.toString()
                                    def remotePath = "$remoteDir/$relativePath"
                                    def remoteParentDir = remotePath.substring(0, remotePath.lastIndexOf('/'))

                                    // Ensure the parent directory exists
                                    execute "mkdir -p $remoteParentDir"

                                    println("Uploading: $fileDetails.file to $remotePath")
                                    put from: fileDetails.file, into: remotePath
                                }
                            }
                        } else {
                            println("Uploading file: $localFiles to $remoteDir")
                            put from: file(localFiles), into: "$remoteDir"
                        }
                    }
                }
            }
        }
    }
}

void remoteCommandsBlock(hostConfig, taskConfig) {
    ssh.run {
        session(ssh.remotes[hostConfig.name]) {
            taskConfig.commands.each { commandsConfig ->
                Map options = new HashMap()
                if (commandsConfig instanceof Map) {
                    commandsConfig.each { command, optionMap ->
                        optionMap.each { key, value ->
                            if (value instanceof Map) {
                                value.each { entry, val ->
                                    if(key == "options") {
                                        options[entry] = val
                                    }
                                }
                            }
                        }

                        println("Executing command on ${hostConfig.name}: $command")

                        if (command.toString().startsWith("sudo ")) {
                            executeSudo(command.substring(5), *: options) { result ->
                                println(result)
                            }
                        } else {
                            execute(command, *: options) { result ->
                                println(result)
                            }
                        }
                    }
                } else {
                    if (commandsConfig.toString().startsWith("sudo ")) {
                        executeSudo(commandsConfig.substring(5)) { result ->
                            println(result)
                        }
                    } else {
                        execute(commandsConfig) { result ->
                            println(result)
                        }
                    }
                }
            }
        }
    }
}

void awaitCommandsBlock(hostConfig, taskConfig) {
    taskConfig.await.each { awaitCommandsConfig ->
        def options = new HashMap()
        def waitFor = new HashMap()
        if (awaitCommandsConfig instanceof Map) {
            awaitCommandsConfig.each { command, modifiers ->
                modifiers.each { key, value ->
                    if (value instanceof Map) {
                        value.each { entry, val ->
                            if (key == "options") {
                                options[entry] = val
                            } else if (key == "conditions") {
                                waitFor[entry] = val
                            }
                        }
                    }
                }

                boolean conditionsMet = false
                String outputBuffer
                int exitCode

                while (!conditionsMet) {
                    ssh.run {
                        session(ssh.remotes[hostConfig.name]) {
                            if (command.toString().startsWith("sudo ")) {
                                try {
                                    outputBuffer = executeSudo(command.substring(5), *: options)
                                    exitCode = 0
                                } catch (Exception e) {
                                    exitCode = e.exitStatus
                                }
                            } else {
                                try {
                                    outputBuffer = execute(command, *: options)
                                    exitCode = 0
                                } catch (Exception e) {
                                    exitCode = e.exitStatus
                                }
                            }
                        }
                    }

                     waitFor.each { condition, value ->
                        switch (condition) {
                            case "matchOutput":
                                conditionsMet = outputBuffer.contains(value)
                                break
                            case "!matchOutput":
                                conditionsMet = !outputBuffer.contains(value)
                                break
                            case "exitCode":
                                conditionsMet = value == exitCode
                                break
                            default:
                                throw new GradleException("Unknown condition: $condition")
                        }
                    }

                    sleep(5000)
                }
            }
        }
    }
}