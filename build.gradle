import groovy.json.JsonSlurper

import java.nio.file.FileVisitResult
import java.nio.file.SimpleFileVisitor
import java.nio.file.attribute.BasicFileAttributes
import java.util.regex.Pattern
import java.nio.file.Paths
import java.nio.file.Files

plugins {
    id 'java'
    id 'com.gradleup.shadow' version '9.0.0-beta4'
    id 'org.hidetake.ssh' version '2.11.2'
}

group = project.group
version = project.version
description = project.description

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(project.javaVersion)
    }
}

repositories {
    maven {
        url = uri('https://nexus.ailis.de/content/groups/public/')
    }
    mavenCentral()
}

dependencies {
    implementation 'org.usb4java:usb4java:1.3.0'
//    implementation 'org.openpnp:opencv:4.9.0-0'
}

tasks.assemble.dependsOn(shadowJar)

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.jar {
    manifest {
        attributes(
                'Main-Class': 'RobotControl.DriverServer'
        )
    }
}

def configFile = file('deployment.json')

if (!configFile.exists()) {
    logger.lifecycle("Configuration file 'deployment.json' not found. Creating a template...")

    def templateContent = '''{
      "hosts": [
        {
          "name": "host1",
          "hostname": "192.168.1.10",
          "username": "admin",
          "password": "securepassword",
          "port": 22,
          "deployDirectory": "/path/to/dir",
          "deployedFiles":  [
            {
              "${rootDir}/build": [
                "program.jar"
              ]
            }
          ], "commands": [
            "echo \"hello server 1!\""
          ]
        },
        {
          "name": "host2",
          "hostname": "example.com",
          "username": "root",
          "keyFile": "/path/to/private/key",
          "deployDirectory": "/path/to/dir",
          "deployedFiles":  [
            {
              "${rootDir}/build": [
                "program-${version}-all.jar"
              ], "${rootDir}/resources": [
                "**"
              ], "${rootDir}/testing": [
                "test*/*"
              ], "${rootDir/external}": [
                "*.dll",
                "*.so",
                "*.dylib"
              ]
            }
          ], "commands": [
            "echo \"hello!\""
          ]
        }
      ]
    }'''

    configFile.text = templateContent
    throw new GradleException("Template 'deployment.json' has been created. Please fill in the required details, or if no desired remotes, leave the file blank and rerun the build.")
}

def jsonSlurper = new JsonSlurper()
def hostsConfig = jsonSlurper.parse(configFile)

def resolvePlaceholders(input) {
    if (input instanceof String) {
        def resolved = input
        project.properties.each { key, value ->
            if(key != null) {
                resolved = resolved.replaceAll(Pattern.quote("\${${key}}"), value.toString())
            }
        }
        return resolved
    }
    return input
}

hostsConfig.hosts.each { host ->
    host.each { key, value ->
        if(value instanceof String) {
            host[key] = resolvePlaceholders(value)
        } else if(value instanceof List) {
            host[key] = value.collect { v ->
                if (v instanceof Map) {
                    v.collectEntries { k, v2 ->
                        [resolvePlaceholders(k), resolvePlaceholders(v2)]
                    }
                } else {
                    resolvePlaceholders(v)
                }
            }
        }
    }
}


ssh.remotes {
    hostsConfig.hosts.each { hostConfig ->
        def remoteName = hostConfig.name
        logger.lifecycle("Configuring remote host: $remoteName")

        "$remoteName" {
            host = hostConfig.hostname
            user = hostConfig.username
            port = hostConfig.port ?: 22 // Default to port 22 if not specified
            if (hostConfig.password) {
                password = hostConfig.password
            } else if (hostConfig.keyFile) {
                identity = file(hostConfig.keyFile)
            }
        }
    }
}

ssh.settings {
    knownHosts = project.hasProperty('knownHosts') ? project.knownHosts : allowAnyHosts
}

tasks.register('deploy') {
    dependsOn build
    doLast {
        ssh.remotes.each { remoteName, remote ->
            def hostConfig = hostsConfig.hosts.find { it.name == remoteName }

            if (hostConfig && hostConfig.deployDirectory && hostConfig.deployedFiles) {
                ssh.run {
                    session(remote) {
                        hostConfig.deployedFiles.each { entry ->
                            entry.each { baseDir, fileSelector ->
                                entry.each { filePattern ->
                                    def path = Paths.get(baseDir)
                                    def matcher = (filePattern as String).replace('**', '.*').replace('*', '[^/]*')
                                    def matchedFiles = []

                                    if ((filePattern as String).startsWith('**')) {
                                        // Recursive search for ** pattern
                                        Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
                                            @Override
                                            FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                                                if (file.toString().matches(matcher)) {
                                                    matchedFiles << file.toString()// Add full path to the matched list
                                                }
                                                return FileVisitResult.CONTINUE
                                            }

                                            @Override
                                            FileVisitResult visitFileFailed(Path file, IOException exc) {
                                                return FileVisitResult.CONTINUE
                                            }
                                        } as java.nio.file.FileVisitor<? super java.nio.file.Path>)
                                    } else if ((filePattern as String).contains('*')) {
                                        // Single-level search for * pattern
                                        Files.newDirectoryStream(path, matcher).each { file ->
                                            matchedFiles << file.toString()  // Add full path to the matched list
                                        }
                                    } else {
                                        matchedFiles << filePattern
                                    }

                                    matchedFiles.each { File file ->
                                        put from: (baseDir + file), into: hostConfig.deployDirectory
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                logger.lifecycle("No deployDirectory or deployedFiles found for host: ${remoteName}")
            }
        }
    }
}


tasks.register('remoteRun') {
    dependsOn deploy
    doLast {
        ssh.remotes.each { remoteName, remote ->
            def hostConfig = hostsConfig.hosts.find { it.name == remoteName }

            if (hostConfig && hostConfig.commands) {
                ssh.run {
                    session(remote) {
                        hostConfig.commands.each { command ->
                            execute command
                        }
                    }
                }
            } else {
                logger.lifecycle("No commands found for host: ${remoteName}")
            }
        }
    }
}