import groovy.json.JsonSlurper

plugins {
    id 'java'
    id 'com.gradleup.shadow' version '9.0.0-beta4'
    id 'org.hidetake.ssh' version '2.11.2'
}

group = project.group
version = project.version
description = project.description

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(project.javaVersion)
    }
}

repositories {
    maven {
        url = uri('https://nexus.ailis.de/content/groups/public/')
    }
    mavenCentral()
}

dependencies {
    implementation 'org.usb4java:usb4java:1.3.0'
//    implementation 'org.openpnp:opencv:4.9.0-0'
}

tasks.assemble.dependsOn(shadowJar)

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.jar {
    manifest {
        attributes(
                'Main-Class': 'RobotControl.DriverServer'
        )
    }
}

def configFile = file('deployment.json')

if (!configFile.exists()) {
    logger.lifecycle("Configuration file 'deployment.json' not found. Creating a template...")

    def templateContent = '''{
  "hosts": [
    {
      "name": "exampleHost",
      "hostname": "example.com",
      "username": "user123",
      "password": "superSecurePassword",
      "port": 22,
      "fileTransfer": [
        {
          "directory": "/remote/deploy/dir",
          "files": [
            {
              "directory": "${rootDir}/build",
              "files": [
                "program-${version}.jar"
              ]
            },
            {
              "directory": "${rootDir}/resources"
            },
            {
              "files": "${rootDir}/docs/**/*.html"
            }
          ]
        }
      ],
      "commands": [
        "echo 'Hello from remote server!'"
      ]
    }
  ]
}'''

    configFile.text = templateContent
    throw new GradleException("Template 'deployment.json' has been created. Please fill in the required details, or if no desired remotes, leave the file blank and rerun the build.")
}

def jsonSlurper = new JsonSlurper()
def hostsConfig = jsonSlurper.parse(configFile)

String resolvePlaceholders(String value) {
    return value.replaceAll(/\$\{([^}]+)\}/) { match ->
        def key = match[1]
        def resolved = project.hasProperty(key) ? project.property(key) : null
        if (resolved == null) {
            logger.warn("Warning: No value found for key: ${key}")
            return ""
        }
        return resolved
    }
}

void resolveConfigPlaceholders(Object node) {
    if (node instanceof Map) {
        node.each { key, value ->
            if (value instanceof String) {
                node[key] = resolvePlaceholders(value)
            } else {
                resolveConfigPlaceholders(value)
            }
        }
    } else if (node instanceof List) {
        node.eachWithIndex { value, idx ->
            if (value instanceof String) {
                node[idx] = resolvePlaceholders(value)
            } else {
                resolveConfigPlaceholders(value)
            }
        }
    }
}
resolveConfigPlaceholders(hostsConfig)

ssh.remotes {
    hostsConfig.hosts.each { hostConfig ->
        def remoteName = hostConfig.name
        logger.lifecycle("Configuring remote host: $remoteName")

        "$remoteName" {
            host = hostConfig.hostname
            user = hostConfig.username
            port = hostConfig.port ?: 22 // Default to port 22 if not specified
            if (hostConfig.password) {
                password = hostConfig.password
            } else if (hostConfig.keyFile) {
                identity = hostConfig.keyFile
            } else {
                throw new GradleException("No password or keyFile specified for host: $remoteName")
            }
        }
    }
}
ssh.settings {
    knownHosts = project.hasProperty('knownHosts') ? project.knownHosts : allowAnyHosts
}

tasks.register('deploy') {
    dependsOn build
    doLast {
        hostsConfig.hosts.each { hostConfig ->
            ssh.run {
                session(ssh.remotes[hostConfig.name]) {
                    hostConfig.fileTransfer.each { transferConfig ->
                        def remoteDir = transferConfig.directory
                        if (!remoteDir) {
                            throw new GradleException("Remote directory is not specified for host: ${hostConfig.name}")
                        }

                        transferConfig.files.each { fileConfig ->
                            if (fileConfig.directory && fileConfig.files) {
                                def localDir = resolvePlaceholders(fileConfig.directory)
                                def localFilePatterns = fileConfig.files.collect { resolvePlaceholders(it) }
                                logger.lifecycle("Uploading specified files from $localDir to $remoteDir with patterns: $localFilePatterns")

                                localFilePatterns.each { pattern ->
                                    fileTree(dir: localDir, include: pattern).visit { fileDetails ->
                                        if (!fileDetails.directory) {
                                            def relativePath = fileDetails.relativePath.toString()
                                            def remotePath = "$remoteDir/$relativePath"
                                            def remoteParentDir = remotePath.substring(0, remotePath.lastIndexOf('/'))

                                            // Ensure the parent directory exists
                                            logger.lifecycle("Ensuring remote directory exists: $remoteParentDir")
                                            execute "mkdir -p $remoteParentDir"

                                            logger.lifecycle("Uploading: $fileDetails.file to $remotePath")
                                            put from: fileDetails.file, into: remotePath
                                        }
                                    }
                                }
                            } else if (fileConfig.directory) {
                                def localDir = resolvePlaceholders(fileConfig.directory)
                                logger.lifecycle("Uploading directory: $localDir to $remoteDir")

                                fileTree(localDir).visit { fileDetails ->
                                    if (!fileDetails.directory) {
                                        def relativePath = fileDetails.relativePath.toString()
                                        def remotePath = "$remoteDir/$relativePath"
                                        def remoteParentDir = remotePath.substring(0, remotePath.lastIndexOf('/'))

                                        // Ensure the parent directory exists
                                        logger.lifecycle("Ensuring remote directory exists: $remoteParentDir")
                                        execute "mkdir -p $remoteParentDir"

                                        logger.lifecycle("Uploading: $fileDetails.file to $remotePath")
                                        put from: fileDetails.file, into: remotePath
                                    }
                                }
                            } else if (fileConfig.files) {
                                def localFiles = resolvePlaceholders(fileConfig.files)

                                // Detect wildcard usage
                                if (localFiles.contains("**")) {
                                    def baseDir = localFiles.substring(0, localFiles.indexOf("**")).trim()
                                    logger.lifecycle("Uploading wildcard files from: $baseDir with pattern: $localFiles to $remoteDir")

                                    fileTree(dir: baseDir, include: localFiles.substring(baseDir.length())).visit { fileDetails ->
                                        if (!fileDetails.directory) {
                                            def relativePath = fileDetails.relativePath.toString()
                                            def remotePath = "$remoteDir/$relativePath"
                                            def remoteParentDir = remotePath.substring(0, remotePath.lastIndexOf('/'))

                                            // Ensure the parent directory exists
                                            logger.lifecycle("Ensuring remote directory exists: $remoteParentDir")
                                            execute "mkdir -p $remoteParentDir"

                                            logger.lifecycle("Uploading: $fileDetails.file to $remotePath")
                                            put from: fileDetails.file, into: remotePath
                                        }
                                    }
                                } else {
                                    logger.lifecycle("Uploading specific file: $localFiles to $remoteDir")

                                    put from: file(localFiles), into: "$remoteDir"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

tasks.register('remoteRun') {
    dependsOn deploy
    doLast {
        hostsConfig.hosts.each { hostConfig ->
            ssh.run {
                session(ssh.remotes[hostConfig.name]) {
                    hostConfig.commands.each { command ->
                        Map options = new HashMap()
                        if (command instanceof Map) {
                            command.each { cmd, optionMap ->
                                optionMap.each { key, value ->
                                    if (value instanceof Map) {
                                        value.each { entry, val ->
                                            options[entry] = val
                                        }
                                    } else {
                                        options[key] = value
                                    }
                                }

                                command = cmd

                                logger.lifecycle("Executing command on ${hostConfig.name}: $command")
                                logger.lifecycle("Options map: " + options)

                                if (command.toString().startsWith("sudo ")) {
                                    executeSudo(command.substring(5), *: options) { result ->
                                        logger.lifecycle(result)
                                    }
                                } else {
                                    execute(command, *:options)  { result ->
                                        logger.lifecycle(result)
                                    }
                                }
                            }
                        } else {
                            if (command.toString().startsWith("sudo ")) {
                                executeSudo(command.substring(5)) { result ->
                                    logger.lifecycle(result)
                                }
                            } else {
                                execute(command)  { result ->
                                    logger.lifecycle(result)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

